<!-- 5057a2c2-ac71-442f-b494-9833deb7c136 2efa5368-4452-4513-baa6-73508ec9ed80 -->
# Title

Persistent Testcontainers env across reruns (Vitest 3.2.4 + VSCode)

### Approach (3 steps)

- Create all infra once in `globalSetup` (Postgres + S3 + Firebase Auth emulator), and write a persisted env file with connection details.
- Inject env into every worker run via `setupFiles` (and optional `test.provide`) so tests receive the same values even when `globalSetup` doesn’t re-execute.
- Use `onRerun` (optional) to refresh in-memory caches if needed; primary mechanism is re-reading the persisted env on each worker start.

### Why this works (per docs)

- `globalSetup` may not run before each rerun in watch/IDE mode; values must be persisted externally. See Global Setup: [vitest.dev/config/#globalsetup](https://vitest.dev/config/#globalsetup).
- `test.provide` and `setupFiles` are designed to pass data to workers on each run; we’ll use a `setupFiles` reader to populate `process.env` consistently. See Provide: [vitest.dev/config/#provide](https://vitest.dev/config/#provide) and Config: [vitest.dev/config](https://vitest.dev/config/).
- Test Projects are supported; we’ll use a single “superset” project to always bring up all services: [vitest.dev/guide/browser/config/#projects-support](https://vitest.dev/guide/browser/config/#projects-support).

### Files to add/update

- `vitest.workspace.ts`: single project `e2e` (or keep your existing projects, but all share the same globalSetup and setupFiles).
- `vitest.config.ts`: base defaults only; delegate to workspace.
- `tests/setup/globalSetup.all.ts`: start Postgres + LocalStack(S3) + Firebase Auth emulator; wait-ready; run Prisma; create bucket; write JSON to `tests/.state/test-env.json`; return teardown.
- `tests/setup/provideEnv.ts`: read `tests/.state/test-env.json` and set `process.env` per worker at file-eval time. Because `setupFiles` run once per file, we will keep env stable by not recreating containers on reruns. Add a tiny `tests/setup/ensureTestEnv.ts` helper that can be imported by infra modules (e.g., `src/s3/client.ts`) to reapply env if a module is loaded by the IDE before `setupFiles`.
- (Optional) `tests/setup/onRerun.ts`: exported helper to clear memoized SDK clients.
- (Optional) make S3 and Firebase Admin lazy-initialized (created on first use) to avoid stale env at import time.

### Persisted env format

- Path: `tests/.state/test-env.json`
- Example keys:
  - `DATABASE_URL`
  - `R2_ENDPOINT`, `R2_ACCESS_KEY_ID`, `R2_SECRET_ACCESS_KEY`, `R2_BUCKET`
  - `FIREBASE_AUTH_EMULATOR_HOST`, `FIREBASE_PROJECT_ID`

### Essential snippets

- `tests/setup/globalSetup.all.ts`
```ts
import { GenericContainer, Wait } from 'testcontainers';
import { execSync } from 'node:child_process';
import fs from 'node:fs'; import path from 'node:path';

export default async function globalSetup() {
  // Start Postgres
  const pg = await new GenericContainer('postgres:16-alpine')
    .withEnvironment({ POSTGRES_USER: 'postgres', POSTGRES_PASSWORD: 'password', POSTGRES_DB: 'btfp_test' })
    .withExposedPorts(5432)
    .withWaitStrategy(Wait.forLogMessage('database system is ready to accept connections'))
    .start();
  const pgUrl = `postgresql://postgres:password@${pg.getHost()}:${pg.getMappedPort(5432)}/btfp_test`;

  // Start LocalStack (S3)
  const s3 = await new GenericContainer('localstack/localstack:2.3')
    .withEnvironment({ SERVICES: 's3', EDGE_PORT: '4566', DEBUG: '1' })
    .withExposedPorts(4566)
    .withWaitStrategy(Wait.forLogMessage('Ready.'))
    .start();
  const endpoint = `http://${s3.getHost()}:${s3.getMappedPort(4566)}`;

  // Create bucket
  const { S3Client, CreateBucketCommand } = await import('@aws-sdk/client-s3');
  const s3c = new S3Client({ region: 'us-east-1', endpoint, forcePathStyle: true, credentials: { accessKeyId: 'test', secretAccessKey: 'test' } });
  const bucket = 'btfp-test';
  try { await s3c.send(new CreateBucketCommand({ Bucket: bucket })); } catch {}

  // Start Firebase Auth emulator
  const auth = await new GenericContainer('evolutecx/firebase-emulator:latest')
    .withExposedPorts(9099)
    .start();
  const fbHost = `${auth.getHost()}:${auth.getMappedPort(9099)}`;
  const projectId = 'demo-test';

  // Prepare DB (Prisma)
  const repo = path.resolve(__dirname, '../..');
  execSync('npx prisma generate', { stdio: 'inherit', cwd: repo, env: { ...process.env } });
  execSync('npx prisma db push --skip-generate', { stdio: 'inherit', cwd: repo, env: { ...process.env, DATABASE_URL: pgUrl } });

  // Persist env
  const stateDir = path.resolve(repo, 'tests/.state'); fs.mkdirSync(stateDir, { recursive: true });
  const env = {
    DATABASE_URL: pgUrl,
    R2_ENDPOINT: endpoint,
    R2_ACCESS_KEY_ID: 'test',
    R2_SECRET_ACCESS_KEY: 'test',
    R2_BUCKET: bucket,
    FIREBASE_AUTH_EMULATOR_HOST: fbHost,
    FIREBASE_PROJECT_ID: projectId,
  };
  fs.writeFileSync(path.resolve(stateDir, 'test-env.json'), JSON.stringify(env, null, 2));

  // Teardown once Vitest exits
  return async () => { await Promise.allSettled([pg.stop(), s3.stop(), auth.stop()]); };
}
```

- `tests/setup/provideEnv.ts`
```ts
import fs from 'node:fs'; import path from 'node:path';

function loadPersistedEnv(): Record<string, string> {
  const repo = path.resolve(__dirname, '../..');
  const p = path.resolve(repo, 'tests/.state/test-env.json');
  const raw = fs.readFileSync(p, 'utf8');
  return JSON.parse(raw);
}

const env = loadPersistedEnv();
for (const [k, v] of Object.entries(env)) {
  if (typeof v === 'string') process.env[k] = v;
}
```

- `vitest.workspace.ts` (single superset project)
```ts
import { defineWorkspace } from 'vitest/config';
export default defineWorkspace([
  {
    extends: './vitest.config.ts',
    test: {
      name: 'e2e',
      include: ['tests/**/*.{test,int.test,auth.int.test}.ts'],
      setupFiles: ['tests/setup/provideEnv.ts'],
      globalSetup: ['tests/setup/globalSetup.all.ts'],
      testTimeout: 120000, hookTimeout: 120000,
    },
  },
]);
```

- `vitest.config.ts` (base defaults only)
```ts
import { defineConfig } from 'vitest/config';
export default defineConfig({ test: { environment: 'node', globals: true, pool: 'forks' } });
```

- Optional: add `onRerun` to clear memoized clients
```ts
// in vitest.config.ts inside test: {}
onRerun: () => {
  // if you memoize AWS/Firebase clients, clear here
}
```


### Script updates

- `test`: `vitest run --config vitest.workspace.ts`
- Or keep your three projects, but set `setupFiles: ['tests/setup/provideEnv.ts']` and `globalSetup: ['tests/setup/globalSetup.all.ts']` for all.

### Notes

- Make SDK clients (S3/Firebase) lazy to read env at first use, not at import time (avoids stale env when IDE preloads files).
- VSCode Vitest extension: set “Vitest: Project” to `vitest.workspace.ts` so single-file runs use the same project/globalSetup.

### Outcome

- First run: containers start, env is persisted, tests get env via `setupFiles`.
- Subsequent reruns: tests reload persisted env regardless of whether `globalSetup` re-executes.
- Both single-test and whole-folder runs work consistently in the extension and CLI.

### To-dos

- [ ] Create single superset Vitest project in vitest.workspace.ts
- [ ] Implement globalSetup.all.ts to start DB/S3/Auth and persist env JSON
- [ ] Add provideEnv.ts to inject persisted env into workers
- [ ] Make S3 and Firebase Admin clients lazy-initialized to read env on first use
- [ ] Update package scripts to run workspace project consistently